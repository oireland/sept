generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}


// in the next auth boilerplate but I don't think I need them
// model Account {
//   id                 String  @id @default(cuid())
//   userId             String
//   type               String
//   provider           String
//   providerAccountId  String
//   refresh_token      String?  @db.Text
//   access_token       String?  @db.Text
//   expires_at         Int?
//   token_type         String?
//   scope              String?
//   id_token           String?  @db.Text
//   session_state      String?

//   user User @relation(fields: [userId], references: [id], onDelete: Cascade)

//   @@unique([provider, providerAccountId])
// }
// model Session {
//   id           String   @id @default(cuid())
//   sessionToken String   @unique
//   userId       String
//   expires      DateTime
//   user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
// }

enum UserRole {
  HOST
  ATHLETE
  STAFF
  SPECTATOR
}

model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?  @unique
  emailVerified DateTime?
  isConfirmed Boolean @default(false)
  password String?
  image         String?
  role UserRole @default(SPECTATOR)
  host Host? @relation("User - Host")
  athlete Athlete? @relation("User - Athlete")
  staff Staff? @relation("User - Staff")
  spectator Spectator? @relation("User - Spectator")
}

model Spectator {
  id String @id @default(cuid())
  name String
  user User @relation("User - Spectator", fields: [userId], references: [id], onDelete: Cascade)
  userId String @unique
  hosts Host[] @relation("Hosts - Spectators")    // in the case of a parent having children from different schools that use SEPT
}

model Host {
  id String @id @default(cuid())
  user User @relation("User - Host", fields: [userId], references: [id], onDelete: Cascade)
  userId String @unique
  name String
  athletes Athlete[] @relation("Host - Athletes")
  events Event[] @relation("Host - Events")
  staff Staff[] @relation("Host - Staff")
  spectators Spectator[] @relation("Hosts - Spectators")
  groups String[]
  teams String[]
}

// Potential Idea: As a host you have competitions, the competition has the events, athletes, staff etc. 
// Implement later if seems necessary
// or a host has competitions but still the athletes and staff. competitions have events
// probably unnecessary

model Staff {
  id String @id @default(cuid())
  name String
  user User @relation("User - Staff", fields: [userId], references: [id], onDelete: Cascade)
  userId String @unique
  host Host @relation("Host - Staff" ,fields: [hostId], references: [id], onDelete: Cascade)
  hostId String
  events Event[] @relation("StaffMember - Events")
}

enum BoyOrGirl {
  BOY
  GIRL
}

model Athlete {
  id String @id @default(cuid())
  name String
  group String // will be checked against the groups in the host when an Athlete is created
  team String // ^^
  user User @relation("User - Athlete", fields: [userId], references: [id], onDelete: Cascade)
  userId String @unique
  host Host @relation("Host - Athletes", fields: [hostId], references: [id], onDelete: Cascade)
  hostId String @unique
  events Event[] @relation("Athletes - Events")
  boyOrGirl BoyOrGirl

}

enum EventType {
  TRACK
  FIELD
}
// If an event is a track event then lowest score = first place
// Field events opposite

model Event {
  id String @id @default(cuid())
  name String
  eventType EventType
  athletesBoyOrGirl BoyOrGirl
  group String
  host Host @relation("Host - Events", fields: [hostId], references: [id], onDelete: Cascade)
  hostId String
  athletesCompeting Athlete[] @relation("Athletes - Events")
  staffMember Staff @relation("StaffMember - Events", fields: [staffId], references: [id])
  staffId String
}

// current working User model
// model User {
//   id            String    @id @default(cuid())
//   name          String?
//   email         String?  @unique
//   emailVerified DateTime?
//   isConfirmed Boolean @default(false)
//   password String?
//   image         String?
//   role UserRole @default(SPECTATOR)
//   accounts      Account[]
//   sessions      Session[]
// }

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}
